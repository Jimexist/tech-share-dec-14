<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Madadata Tech Share - Dec 14th 2016</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<section>
				<h1>FP Primer for OOP Programmers</h1>
				<h3>
						Jiayu Liu
					</h3>
				<p>Madadata Tech Share (Internal, Not for Sharing)</p>
				<p>
					<small>Dec 14th 2016</small>
				</p>
			</section>

			<section>
				<h2>Disclaimer</h2>
				<p>I did not consult nor check up any textbooks or official definitions while making this slides - read with care if you need verbatim quotes</p>
			</section>

			<section>
				<h2>OOP v.s. FP</h2>
				<p class="fragment">OOP is more widely known</p>
				<p class="fragment">FP is deeply rooted in lambda calculus</p>
				<p class="fragment">both are powerful thought-weapons to attack problems</p>
			</section>

			<section>
				<h2>Typical OOP concept - <q><a target="_blank" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a></q></h2>
				<ul>
					<li class="fragment"><em>S</em>ingle responsibility principle</li>
					<li class="fragment"><em>O</em>pen/closed principle</li>
					<li class="fragment"><em>L</em>iskov substitution principle</li>
					<li class="fragment"><em>I</em>nterface segregation principle</li>
					<li class="fragment"><em>D</em>ependency inversion principle</li>
				</ul>
			</section>

			<section>
				<h2>In OOP, everything is an object</h2>
				<p class="fragment">there are objects</p>
				<p class="fragment">they send messages to each others</p>
				<p class="fragment">each object respond to messages accordingly (and differently)</p>
				<p class="fragment">to be precise, SmallTalk, Objective-C or even Erlang stick to this rule more strictly than Java</p>
			</section>

			<section>
				<h2>Design Patterns</h2>
				<p class="fragment">cost-effective way to implement some repetitive paradigms in programming</p>
				<p class="fragment">many people love it, stick to it, even make it textbook</p>
				<p class="fragment">the famous <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank">gang-of-four</a></p>
				<p class="fragment">some others dispise it</p>
				<blockquote class="fragment" cite="http://www.paulgraham.com/icad.html">
					<p>&ldquo;Human compiler at work&rdquo; <a href="http://www.paulgraham.com/icad.html" target="_blank">Paul Graham</a></p>
				</blockquote>
			</section>

			<section>
				<h2>Introducing FP</h2>
				<p class="fragment">In Java, methods cannot exist without an object (<a href="https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank">famous must-read rant</a>)</p>
				<p class="fragment">In FP, functions are the first class citizen</p>
				<p class="fragment">functions can take, use, transform, and return functions (and data)</p>
				<p class="fragment">data (or <em>the nouns</em>) is piped through a chain of functions</p>
			</section>

			<section>
				<h2>Functions as the first class citizen</h2>
				<pre><code class="haskell" data-trim>
list = [1, 2, 3]

double n = n + n

square n = n * n

doubledList = map double list -- [2, 4, 6]

squaredList = map square list -- [1, 4, 9]

zipList = zipWith (+) doubledList squaredList -- [3, 8, 15]
				</code></pre>
			</section>

			<section>
				<section>
					<h2>FP promotes referencial transparency</h2>
					<p class="fragment">Just like the function</p>
					<blockquote class="fragment">$y = f(x)$</blockquote>
					<p class="fragment">the value of $y$ does not change given the same $x$</p>
					<p class="fragment">Where as OOP is based on the <em>mutation</em> of states within Objects</p>
				</section>

				<section>
					<h3>Filtering a list in OOP and FP</h3>
					<h4 class="fragment">OOP</h4>
					<pre class="fragment"><code class="lang-java" data-trim>
public static List&lt;Integer&gt; positiveIntegers(List&lt;Integer&gt; list) {
  List&lt;Integer&gt; filtered = new ArrayList&lt;&gt;();
  for (int i=0; i&lt;list.size(); ++i) {
    if (list.get(i) &gt; 0) filtered.add(list.get(i));
  }
  return filtered;
}
					</code></pre>
					<h4 class="fragment">FP</h4>
					<pre class="fragment"><code class="haskell" data-trim>
positives = filter (> 0) -- &ldquo;pointless&rdquo; style
					</code></pre>
					<em class="fragment">Notice the usage of mutating i and container list in OOP</em>
				</section>
			</section>

		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'fade', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [{
				src: 'plugin/markdown/marked.js'
			}, {
				src: 'plugin/markdown/markdown.js'
			}, {
				src: 'plugin/notes/notes.js',
				async: true
			}, {
				src: 'plugin/highlight/highlight.js',
				async: true,
				callback: function() {
					hljs.initHighlightingOnLoad();
				}
			}, {
				src: 'plugin/math/math.js',
				async: true
			}]
		});
	</script>
</body>

</html>
